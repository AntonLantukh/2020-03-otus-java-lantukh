# Сравнение различных GC
**На примере G1 и Parallel GC**

## Параметры запуска JVM

```
-Xms4096m / 512m
-Xmx4096m / 512m
-XX:+UseParallelGC / -XX:+UseG1GC
-Xlog:gc*  
-verbose:gc
```

Два тестируемых кейса для различных размеров хипа: 512m 4096m.

## Характеристика приложения

В цикле создаются объекты Animal, которые добавляются в коллекцию ArrayList.
Каждые 1000 объектов ход приложения приостанавливается на 5 мс (для памяти 512m) / 1мс (для памяти 4096m). 
При этом половина из добавленных объектов удаляется из коллекции.

## Parallel GC
Для сборки Young поколения используется сборщик PS Scavenge.
Для Tenured (Old) поколения используется PS MarkSweep — многопоточная версия Mark-Sweep-Compact алгоритма (пометить выжившие объекты, очистить память от мертвых, уплотнить выжившие)

```
GC name: PS MarkSweep
GC name: PS Scavenge
```

Для Parallel GC характерна сборка мусора при временной полной остановке приложения. При этом в отличие от Serial GC задействуются несколько потоков.
Young поколение разделяется на 3 региона — Eden и 2 Surviver. При этом Tenured регион один.

Процессы сборки мусора разделяются на малую сборку (minor GC), затрагивающую только младшее поколение, старшую сборку (major GC). Бывает и полная сборку (full GC).

Если в процессе очистки памяти в куче для Young поколения не остается свободных регионов, в которые можно было бы копировать выжившие объекты, это приводит к возникновению ситуации Allocation Failure. 
В таком случае сборщик выполняет полную сборку мусора по всей куче при остановленных основных потоках приложения.

Пример такого лога с Allocation Failure. Стоит сказать: что в случае с Parallel GC, приложение будет приостановлено в любом случае:

```
[22.394s][info   ][gc     ] GC(0) Pause Young (Allocation Failure) 96M->25M(491M) 86.680ms
```

## G1 GC

Для сборки Young поколения используется G1 Young Generation. Для Tenured поколения используется G1 Old Generation.

```
GC name: G1 Young Generation
GC name: G1 Old Generation
```

G1 использует региональную сборку. Heap разделяется на множество регионов равного размера (0.5-2 мб).

```
[0.015s][info   ][gc,heap] Heap region size: 2M  
[0.039s][info   ][gc     ] Using G1
```

G1 оценивает размер живых объектов в регионах, это происходит параллельно без остановки потоков приложения.
При следующем цикле GC обрабатывает все Young регионы, а также несколько тех, в которых наименьший размер живых объектов.

Пример работы G1 с регионами:

```
[864.818s][info   ][gc,heap      ] GC(4) Eden regions: 2->0(100)
[864.818s][info   ][gc,heap      ] GC(4) Survivor regions: 2->2(13)
[864.818s][info   ][gc,heap      ] GC(4) Old regions: 0->0
[864.818s][info   ][gc,heap      ] GC(4) Archive regions: 2->2
[864.818s][info   ][gc,heap      ] GC(4) Humongous regions: 753->753
```

Разделение регионов на Eden, Survivor и Tenured в данном случае логическое, регионы одного поколения не обязаны идти подряд и даже могут менять свою принадлежность к тому или иному поколению.

G1 имеет возможность параллельно с работой самого приложения оценивать размеры регоинов, их загруженность мертвыми объектами, выбирать подходящие регионы, очистить которые было бы наиболее эффективно.
Таким образом G1 в отличие от Parallel GC работает параллельно с основным приложением, но паузы STW для него потенциально будут меньше, благодаря тому, что часть работы будет проделана во время работы основного приложения.

Важное уточнение, в G1 есть так называемые "Громадные регионы" (humongous regions). Любой объект размером больше половины региона считается громадным и обрабатывается особым образом.
В частности, такой объект не перемещается между регионами и к нему не подселяют другие объекты.

Это ситуация особенно актуальная для нашего приложения, посколько мы имеем дело с постоянно растущей коллекцией.

Пример такой сборки:

```
[862.204s][info   ][gc           ] GC(2) Pause Young (Concurrent Start) (G1 Humongous Allocation) 1543M->1509M(4096M) 2643.627ms
[571.283s][info   ][gc,task      ] GC(0) Using 8 workers of 8 for evacuation
```

Выделение спциальных регионов под громадные объекты:

```
[574.514s][info   ][gc,heap      ] GC(0) Humongous regions: 909->909
```

## Сравнение GC

### 512m

|                                   | Parallel GC | G1 GC        |
|-----------------------------------|-------------|--------------|
| Колличество сборок мусора (Young) | 6           | 6            |
| Колличество сборок мусора (Old)   | 2           | 2            |
| Среднее время сборки (Young)      | 100ms       | 190ms        |
| Среднее время сборки (Old)        | 640ms       | 165ms        |
| Время жизни приложения            | 4.35s       | 6.52s        |
| Максимальная загрузка процессора  | 14.4%       | 56.3%        |

Стоит дополнительно отметить, что в случае с G1 место имеют еще и так называемые Concurrent сборки.
Логи данной сборки:
```
[82.288s][info   ][gc,marking   ] GC(1) Concurrent Mark From Roots 198.840ms
[82.288s][info   ][gc,marking   ] GC(1) Concurrent Preclean
[82.288s][info   ][gc,marking   ] GC(1) Concurrent Preclean 0.030ms
[82.288s][info   ][gc,marking   ] GC(1) Concurrent Mark (82.089s, 82.288s) 198.901ms
[82.288s][info   ][gc,start     ] GC(1) Pause Remark
[82.289s][info   ][gc           ] GC(1) Pause Remark 246M->136M(512M) 1.050ms
```
В ходе них происходит разметка удаляемых объектов, выявление проблемных мест. 
Такие сборки тоже занимают определенное время, но не блокируют выполнение программы.
С ними общее число сборок доходит до 16.

### 4096m

|                                   | Parallel GC | G1 GC        |
|-----------------------------------|-------------|--------------|
| Колличество сборок мусора (Young) | 4           | 4            |
| Колличество сборок мусора (Old)   | 1           | 2            |
| Среднее время сборки (Young)      | 923ms       | 1976ms       |
| Среднее время сборки (Old)        | 3717ms      | 940ms        |
| Время жизни приложения            | 7.59s       | 7.59s        |
| Максимальная загрузка процессора  | 22.2%       | 90.0%        |

## Общие выводы

С точки зрения потребляемых ресурсов, G1 оказывается довольно требовательным к процессорным мощностям. 
В обоих случаях мы увидели довольно солидное превосходство (загруженность процессора до 56% и 90%). Parallel GC в этом плане ведет себя намного скромнее.

С другой стороны, использование G1 может плодотворно сказаться на снижении времени STW.
В примере с работой на 512m и 4096m G1 уступил по времени Young сборок, но с лихвой компенсировал этот недостаток в случае с Old сборкой.

Срок жизни приложения был чуть выше у G1 при объеме памяти 512m, но в случае ее увеличения разница сошла на нет. Для 4096m оба сборщика отработали почти за 8 минут.

Вместе с тем, кажется, что G1 оказывается уязвимым к негативному влиянию больших объектов, из-за того что управляет больших количеством регионов, но при этом малого объема (в нашем случае 2m). 
Необходимость постоянно расширять регион, пересматривая его размер, возможно, дополнительно съедает определнное количество времени ожидания сборки.

В общем и целом, сложно сделать однозначные выводы на данном примере, поскольку он скорее искуственный. В реальной ситуации при подобной утечке не спасет ни один GC.
В рассмотренном примере не видно однозначного лидерства одного из GC. Да G1, кажется, лучше и быстрее работает с Old поколением, но при этом с увеличением доступной памяти проедает по скорости работы с Young поколением.
Parallel же экономно использует ресурсы процессора, но для малого объема памяти убирает мусор дольше.

Сказать можно наверняка, что G1 выглядит предпочтительным вариантом, там где нужно сократить время STW и там, где нет тех самых "humongous" объектов.
При этом надо быть готовым, что часть процессорных ресурсов будет постоянно использоваться самим G1.

Parallel хорошо подойдет для случаев, когда доступа GC к процессору при работе программы давать не нужно, а при этом определенное увеличение времени STW в моменте не выглядит критичным.
